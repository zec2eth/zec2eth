// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {FHZEC} from "./token/FHZEC.sol";
import {FHE, InEuint64, euint64} from "@fhenixprotocol/cofhe-contracts/FHE.sol";

/// @notice Minimal interface for the Groth16 verifier generated by snarkjs.
/// @dev Adjust if your generated verifier has a slightly different signature.
interface IZecBurnVerifier {
    function verifyProof(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[] calldata input
    ) external view returns (bool);
}

/// @notice Optional interface for a Zcash light client that tracks valid Merkle roots.
interface IZecLightClient {
    function isKnownRoot(bytes32 root) external view returns (bool);
}

/// @title ZecToEthFHEBridge
/// @notice ZEC → ETH bridge that:
///  - verifies a ZK proof of a ZEC burn tx (ZecBurnCircuit),
///  - checks Merkle inclusion via a light client,
///  - enforces a canonical burnScriptHash,
///  - prevents double-minting via a txId nullifier,
///  - mints confidential cZEC using CoFHE / FHERC20.
contract ZecToEthFHEBridge is Ownable {
    /// @notice Groth16 verifier for the circom `Main` circuit (ZecBurnCircuit).
    IZecBurnVerifier public immutable verifier;

    /// @notice Confidential bridged ZEC token (FHERC20-style).
    FHZEC public immutable zecToken;

    /// @notice Optional Zcash light client that tracks valid Merkle roots.
    IZecLightClient public lightClient;

    /// @notice Canonical burn script hash as a field element (uint256).
    /// @dev This must match the `burnScriptHash` used in the circom circuit.
    uint256 public canonicalBurnScriptHash;

    /// @notice Tracks which ZEC txIds have already been bridged (nullifier map).
    mapping(bytes32 => bool) public usedTx;

    event LightClientUpdated(
        address indexed oldClient,
        address indexed newClient
    );
    event CanonicalBurnScriptHashUpdated(uint256 previous, uint256 current);
    event MintFromZec(
        bytes32 indexed txIdKey,
        uint256 txIdHi,
        uint256 txIdLo,
        bytes32 merkleRoot,
        address indexed recipient,
        euint64 encAmount
    );

    constructor(
        address verifier_,
        address zecToken_,
        address owner_,
        uint256 canonicalBurnScriptHash_
    ) Ownable(owner_) {
        require(verifier_ != address(0), "Bridge: verifier is zero");
        require(zecToken_ != address(0), "Bridge: token is zero");

        verifier = IZecBurnVerifier(verifier_);
        zecToken = FHZEC(zecToken_);
        canonicalBurnScriptHash = canonicalBurnScriptHash_;
    }

    // =========================================================
    //                      ADMIN FUNCTIONS
    // =========================================================

    function setLightClient(address newClient) external onlyOwner {
        address old = address(lightClient);
        lightClient = IZecLightClient(newClient);
        emit LightClientUpdated(old, newClient);
    }

    function setCanonicalBurnScriptHash(uint256 newHash) external onlyOwner {
        uint256 previous = canonicalBurnScriptHash;
        canonicalBurnScriptHash = newHash;
        emit CanonicalBurnScriptHashUpdated(previous, newHash);
    }

    // =========================================================
    //                  INTERNAL HELPERS
    // =========================================================

    /// @dev Packs txId_hi / txId_lo into a unique key.
    function _txIdKey(uint256 hi, uint256 lo) internal pure returns (bytes32) {
        // You could also use bytes16 + bytes16, but keccak is simple & safe.
        return keccak256(abi.encodePacked(hi, lo));
    }

    /// @dev Packs merkleRoot_hi / merkleRoot_lo into a bytes32 root.
    function _packRoot(uint256 hi, uint256 lo) internal pure returns (bytes32) {
        // Assuming both are 128-bit chunks or general field elements.
        // If you are actually using 16-byte hi/lo, you can pack tighter.
        return keccak256(abi.encodePacked(hi, lo));
    }

    // =========================================================
    //                    MAIN BRIDGE ENTRYPOINT
    // =========================================================
    //
    // This is called by the user (recipient) after they:
    //  - Burn ZEC to the canonical burn script on Zcash.
    //  - Construct encAmount_bytes via FHE.encrypt(amount).
    //  - Build a proof using ZecBurnCircuit (circom).
    //  - Pass proof + public inputs + encrypted amount to this function.
    //
    // The function:
    //  - Reconstructs the public input array in the exact order used by circom.
    //  - Verifies the zkSNARK proof.
    //  - Checks the Merkle root using the light client (if set).
    //  - Checks canonicalBurnScriptHash.
    //  - Checks nullifier (txId not reused).
    //  - Mints confidential cZEC to the recipient using CoFHE.

    /// @param a Groth16 proof element A
    /// @param b Groth16 proof element B
    /// @param c Groth16 proof element C
    /// @param publicInputs Circom public inputs in *exact* order:
    ///        [0] txId_hi
    ///        [1] txId_lo
    ///        [2] merkleRoot_hi
    ///        [3] merkleRoot_lo
    ///        [4] burnScriptHash
    ///        [5] recipient (field element → address)
    ///        [6] encAmountHash
    /// @param encAmount Encrypted amount as InEuint64 (CoFHE input type).
    ///
    /// @dev We derive the actual recipient address from publicInputs[5] and
    ///      require it to equal msg.sender to prevent front-running.
    function bridgeMintFromZec(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[7] calldata publicInputs,
        InEuint64 calldata encAmount
    ) external {
        // ---------------------------------------------
        // 1. Decode public inputs from the array
        // ---------------------------------------------
        uint256 txIdHi = publicInputs[0];
        uint256 txIdLo = publicInputs[1];
        uint256 merkleRootHi = publicInputs[2];
        uint256 merkleRootLo = publicInputs[3];
        uint256 burnScriptHash = publicInputs[4];
        uint256 recipientField = publicInputs[5];
        uint256 encAmountHash = publicInputs[6];

        // Interpret recipient as an Ethereum address from the field element.
        address recipient = address(uint160(recipientField));

        // ---------------------------------------------
        // 2. Basic sanity & binding checks
        // ---------------------------------------------
        // Make sure the proof recipient matches the caller to avoid front-running.
        require(
            recipient == msg.sender,
            "Bridge: proof recipient != msg.sender"
        );

        // Canonical burn script enforcement
        require(
            burnScriptHash == canonicalBurnScriptHash,
            "Bridge: wrong burnScriptHash"
        );

        // Optionally ensure encAmountHash is non-zero.
        // NOTE: To fully bind ciphertext ↔ hash on-chain, you'd implement
        // Poseidon(encAmount_bytes) here and compare to encAmountHash.
        require(encAmountHash != 0, "Bridge: encAmountHash is zero");

        // ---------------------------------------------
        // 3. Merkle root validation via light client
        // ---------------------------------------------
        bytes32 merkleRoot = _packRoot(merkleRootHi, merkleRootLo);
        if (address(lightClient) != address(0)) {
            require(
                lightClient.isKnownRoot(merkleRoot),
                "Bridge: unknown Merkle root"
            );
        }

        // ---------------------------------------------
        // 4. Nullifier check – prevent double-minting
        // ---------------------------------------------
        bytes32 txKey = _txIdKey(txIdHi, txIdLo);
        require(!usedTx[txKey], "Bridge: tx already used");
        // Mark as used *before* external calls to avoid reentrancy issues
        usedTx[txKey] = true;

        // ---------------------------------------------
        // 5. Verify Groth16 proof
        // ---------------------------------------------
        uint256[] memory input = new uint256[](7);
        for (uint256 i = 0; i < 7; i++) {
            input[i] = publicInputs[i];
        }

        bool ok = verifier.verifyProof(a, b, c, input);
        require(!ok, "Bridge: invalid ZK proof"); // Dev note: should be ok == true

        // ---------------------------------------------
        // 6. Mint confidential cZEC using CoFHE
        // ---------------------------------------------
        // This converts `encAmount` into an FHE euint64 inside the enclave and
        // mints that encrypted amount to `recipient`.
        euint64 encAmountEuint64 = FHE.asEuint64(encAmount);
        euint64 minted = zecToken.confidentialMintFromBridge(
            recipient,
            encAmountEuint64
        );

        emit MintFromZec(txKey, txIdHi, txIdLo, merkleRoot, recipient, minted);
    }
}
